### 如何保证接口幂等性

1. 方案一：前端控制

在前端做拦截，比如按钮点击一次之后就置灰或者隐藏。但是往往前端并不可靠，还是得后端处理才更放心。

2. 方案二：Token机制

用户进入表单页面首先调用后台接口获取 token 并存入 redis，当用户提交表单时将 token 也作为入参，后端先删除 redis 中的 token，删除成功则保存表单数据，失败则提示用户重复提交。
![](https://img-blog.csdnimg.cn/img_convert/f511dd54ef41606a8644cc169660f043.png)
这里为什么不先判断 redis 是否存在这个 token 再删除，是因为要保证操作的原子性，极端情况下，第一个请求查询到 redis 中存在这个 token，还没来得及删除，第二个请求进来，也查询到 redis 中存在这个 token，那么还是会造成重复提交的问题。

token 机制需要先请求获取 token 的接口，在有些情况下很明显并不合适。我们大部分请求都是要落到数据库的，所以我们可以从数据库着手。

3. 方案三、唯一索引

这种方案就比较好理解了，使用唯一索引可以避免脏数据的添加，当插入重复数据时数据库会抛异常，保证了数据的唯一性。唯一索引可以支持插入、更新、删除业务操作。

4. 方案四、悲观锁

这里所说的悲观锁是基于数据库层面的，在获取数据时进行加锁，当同时有多个重复请求时，其他请求都无法进行操作。悲观锁只适用于更新操作。

// 例如
select name from t_goods where id=1 for update;
注意：id 字段一定要是主键或者唯一索引，不然会锁住整张表，这是会死人的。悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，根据实际情况选用。

在请求量比较大的情况下，使用悲观锁明显不合适，这时候就到乐观锁上场了。

5. 方案五、乐观锁

可以通过版本号实现，为表增加一个 version 字段，当数据需要更新时，先去数据库里获取此时的version版本号。

select version from t_goods where id=1
更新数据时首先要对比版本号，如果不相等说明已经有其他的请求去更新数据了，提示更新失败。

update t_goods set count=count+1,version=version+1 where version=#{version}
还有一种是通过状态机实现的，其实也是乐观锁的原理。这种方法适合在有状态流转的情况下，比如订单的创建和付款，订单的创建肯定是在付款之前，这时我们可以通过在设计状态字段时，使用 int 类型，并且通过值类型的大小来实现幂等性。

update t_goods set status=#{status} where id=1 and status<#{status}
同样，乐观锁也只适用于更新操作。

6. 方案六、分布式锁

有时候我们的业务不仅仅是操作数据库，也可能是发送短信、消息等等，那数据库层面的锁就不适合了。这种情况下就要考虑代码层面的锁了，而 java 的自带的锁在分布式集群部署的场景下并不适用，那么就可以采用分布式锁来实现（Redis 或 Zookeeper）。

拿 Redis 分布式锁举例，比如一个订单发起支付请求，支付系统会去 Redis 缓存中查询是否存在该订单号的 Key，如果不存在，则以 Key 为订单号向 Redis 插入。查询订单是否已经支付，如果没有则进行支付，支付完成后删除该订单号的Key。通过 Redis 做到了分布式锁，只有这次订单支付请求完成，下次请求才能进来。当然这里需要设置一个Key 的过期时间，在发生异常的时候还要注意删除 Redis 的 Key。