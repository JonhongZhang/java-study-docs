### 1. 重载与重写的区别
    重载： 同一个方法名有不同的参数
    重写： 同一个方法， 同一个参数，
### 2. java 异常结构
    throwable 任何异常/错误的先祖 （checked）
        exception 异常， 可以从异常状态中恢复
            Runtime Exception 预料之外的异常，通常表示一个bug, unchecked
            其他Exception预料之中的异常
    如何处理异常：
        使用try-catch捕获异常后，记录对应日志，然后将异常抛给调用者
        spring boot 中使用 @ExceptionHandle注解配置拦截器
### 3. static关键字
1. static 修饰的域，我们叫静态域，它是归类所有的，被所有对象所共享，只有一个
2. static修饰的区块，域只会初始化一次
3. static修饰的域或方法，可以直接通过类的名字加上.进行调用
4. static修饰的方法内不能直接使用非静态成员

### 4. 自动拆箱装箱
    基本类型的数据和包装类之间可以自动的相互转换。
    通过xxValue() 与 ValueOf() 实现

### 5. String  为什么是不可变的
    String 是final类型， String类型的修改不是在原来的内存的地址（head）上修改，而是新创建一个对象，重新指向新对象。 

    虽然没办法直接修改head上的value值，但是直接修改stack上的地址，是可以修改值的
    String one = "someString";和String two = "someString";  one和two指向的是一个内存地址
1. why：
   1. 字符串常量池的需要
   2. ● Java中的String对象的哈希码被频繁地使用，字符串不变性保证了hash码的唯一性，因此可以放心地缓
   3. ● 安全性 防止网络连接地址URL被篡改
2. 好处：
   1. heap空间
   2. 字符串是不可变的，所以也是多线程安全的，同一个字符串实例可以被多个线程共享
   3. 字符串是不可变的，所以创建hashcode的时候，不需要重新计算，也就使得字符串适合作为Map中的键
    
### Object 常用方法：
    getClass，hashCode，equal，clone，toString，notify，notifyAll，wait，finalize

1. hashCode的约定:
    a.  在一次Java程序运行中，同一个对调用多次，始终返回相同的值
    b. 如果使用equal()判断两个对象相等，那么HashCode必须相等
    c. 如果两个对象的equal不相等，那么hashCode也可能相等
2. equals()约定:
   a. Object中的equals是== ，来判断地址是否相同，如果要判断内容相同，那么就要使用String中的equals方法。
   b. 而涉及到HashMap的时候，重写equals()，就需要重写hashCode()
   ⅰ. 自反性，一个对equal自己，一定返回true
   ⅱ. 对称性
   ⅲ. 传递性
   ⅳ. 持久性，多次调用x，y都应该返回一致结果
   ⅴ. 非空。x.equal(null)应该返回false
### Java 的三大特性
    ● 封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据，对外界来说它的内部结构是隐藏的，暴露给外界的只是它的访问方法
    ● 继承：继承是为了重用父类代码，两个类若存在IS-A关系就可以使用继承，同时继承也为实现多态做了铺垫
    ● 多态：一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法
如果new一个实例，调用它的方法，如果被调用的方法有继承父类，那么会先执行父类中的方法，这叫做向上转型

#### 实现多态有三个必要条件：继承，重写，向上转型
    在多态中必须存在有继承关系的子类和父类
    重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法
    在多态中需要将子类的引用赋给父类对象，只有这样该引用才能具备技能调用父类的方法和子类的方法
只有满足上述三个条件，我们才能够在同一继承结构中使用统一的逻辑实现代码不同的对象，从而达到执行不同的行为


### 如何解决死锁问题
1. 死锁产生的原因： 
    死锁是由于两个或以上的线程互相持有对方需要的资源，导致这些线程处于等待状态，无法执行。
2. 产生死锁的必要条件： 
   1. 线程对资源的占有是排他性的，一个资源只能被一个线程占有，直到释放。
   2. 请求和保持条件： 一个线程对请求被占有资源发生阻塞时，对已经获得的资源不释放。
   3. 不剥夺：一个线程在释放资源之前，其他的线程无法剥夺占用。
   4. 循环等待：发生死锁时，线程进入死循环，永久阻塞。
3. 如何定位问题： // todo

### final 关键字
    其意义：关键字final表示最终的，不可变的。
    可作用：变量, 方法, 类
    final 修饰的变量只能赋值一次
    final 修饰的方法不能被覆盖，无法被重写
    final 修饰的类无法被继承。

### java  反射的Api 有
1. Field, 提供一个有关类的属性信息， 以及他的动态访问权限
2. Constructor类： 提供有关构造方法的信息， 包括抽象方法。他是用来封装反射类方法的一个类
3. Class类：  表示正在运行的Java应用程序中的类的实例。
4. Object类： Object 是所有java类的父类。所有对象都默认实现类Object 类的方法。

### java中的双亲委派模型，以及如何破坏双亲委派模型
1. 什么是双亲委派模型（双亲委派机制）：当jvm 加载类时， 他不会先自己加载， 他会询问他的父类是否加载过，如果加载过也不再加载，如果没有加载，那么父类会询问其父类是否已经加载， 以此不断询问， 直到最高层的父加载类，如果未加载过， 那么尝试加载，如果加载不了，则反回给子类加载，如果可以加载则加载然后反回给子类。

2. 好处： 双亲委派可以防止核心类被篡改，提升系统安全性

3. 避免重复的类加载，加快速率。
4. 如何打破双亲委派机制：方法1： 继承ClassLoader这样的一个抽象类，然后重写里面的loadClass 方法，这个方法中可以自定义要加载的类使用什么类加载器。
    方法2： 第二种是通过使用线程的上下文加载器，可以通过java.lang.Thread类的setContextClassLoader()这个方法去设置当前类使用的类加载器类型

### 接口和抽象类的区别
    ● 接口更侧重于功能的设计，并且能将具体实现与调用者隔离，一般要以接口隔离原则设计接口，即粒度越细越好。
    ● 抽象类更侧重于提升复用性，在原有的基础上预留扩展点供开发者灵活实现
    ● 区别：接口可以降低模块间耦合性，抽象类可以提升复用性
    ● 相同点：具有较好的扩展性，符合开闭原则
    ● 接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类可以有私有方法或私有变量
    ● 实现接口一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法
    ● 一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现
    ● 接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承
#### 什么时候用抽象类，什么时候用接口
    ● 如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示 一种 has-a 关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。
    ● 从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。
    而接口正好相反，它是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。
### Java8 的新特性
    Stream流

### ArrayList
    特点：ArrayList底层使用的是数组的数据结构
        查询效率高，增删效率低，线程不安全，使用频率高
    常用方法：
        get，add，clone，contains，size，remove
#### ArrayList如何实现排序
● 使用Collections.sort()传入ArrayList，采用默认的方式进行排序（字典序）
● 使用Collections/sort()传入ArrayList和自己实现Commparator接口的类的对象，实现自定义排序
● 使用List.sort()传入自己实现Commparator接口类对象，实现自定义排序

#### 有序的List
● 使用排序方法 sort，TreeSet，TreeMap

#### 用foreach删除List会有什么问题
    增强for循环即foreach循环也就是根据list对象创建一个iterator迭代对象，用这个迭代对象来遍历list，相当于list对象中元素的遍历托管给了iterator，如果耀对list进行增删操作，都必须经过iterator
    每次foreach循环时都有以下两个操作
```java
iterator.hasNext();     //判断是否有下个元素
item = iterator.next(); //下个元素是什么，并把它赋值给item
```
    进入next方法的时候，首先会进入checkForComodification()方法，也就是说modCount != expectedModCount，那么就会抛出异常
####  具体原因：     
    expectedModCount参数，这个生成iterator的时候期望List中修改元素的次数，如果你在遍历过程中删除元素，List中的modCount就会变化（modCount++）,这样不一致，也就会报错
#### 解决方法
    使用hasNext()来判断，然后用iterator.next()来获取下一个元素

### IO 中用到的设计模式
    适配器模式与装饰器模式

### lock 和 synchronized
1. synchronizedS是Java中的同步关键字
2. lock是JUC包中提供的接口, 该接口有许多的实现类,ReentrantLock重入锁实现
3. synchronized有两种方式控制锁的力度: 1. 修饰在方法上, 2. 修饰在代码块上; 通过synchronized加锁对象的生命周期来控制锁的范围- 入锁对象是静态对象或者类对象那么这个锁就是全局锁, 如果锁对象是普通实例对象那么这个锁的范围取决于这个对象实例的生命周期;
4. lock中锁的力度是通过lock()方法与unlock()方法来决定的. 在两个方法之间的代码是能够保证线程安全的.而锁的作用于取决于lock()实例的生命周期
5. lock的灵活性比synchronized高lock 可以自主的决定什么时候加锁什么时候释放锁,只需要调用lock()与unlock()方法即可
6. lock提供了非阻塞竞争锁的方法,tryLock(), 这个方法可以通过返回 true/false来告诉当前线程是否已经有其他线程在使用锁\
7. synchronized由于是关键字所以他无法去实现非阻塞竞争锁的方法, 另外synchronized的释放是被动的, 当synchronized修饰的部分执行结束后,或者代码出现异常时才回被释放
8. lock提供了公平锁和非公平锁的机制: 公平锁是指线程竞争锁的资源的时候如果已经有其他线程正在排队的时候, 当前竞争锁的线程是无法进行插队的, 而非公平锁不论释放有排队等待的线程, 竞争锁的线程都会去尝试竞争获取锁
9. synchronized只提供了一种公平锁的实现,
10. 重性能方面来看, synchronized 与lock差别不大
11. 实现上: synchronized 引入 偏向锁, 轻量级锁, 重量级锁,以及锁升级的机制来去实现锁的优化
    1. lock中通过自旋锁的方式实现性能优化