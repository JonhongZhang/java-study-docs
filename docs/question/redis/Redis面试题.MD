### redis 数据类型以及目的
1. String: 字符串类型, 常被用来存储计数器, 粉丝数, 简单的分布式锁也会用到该类型
2. hash: key - value 形式的, value 是一个map
3. list: 基本的数据类型, 列表. 在Redis中可以把list用作栈, 队列, 阻塞队列.
4. set: 集合, 不能有重复元素, 可以做点赞, 收藏等
5. zset: 有序集合, 不能有重复元素, 有序集合中的每一个元素都需要指定一个分数, 根据分数对元素进行升序
6. geospatial: redis在3.2推出Geo类型, 该功能可以推算出地理位置信息, 两地之间的距离
7. hyperloglog: 基数: 数学上集合的元素个数, 是不能重复的. 这个数据结构常用于统计网站的UA
8. bitmap: 就是通过最小的单位bit来进行0或者1的设置, 表示某个元素对应的值或者状态, 一个bit的值,或者是0,或者是1;也就是说一个bit能存储的最多信息是2, bitmap常用于统计用户信息比如活跃粉丝和不活跃粉丝, 登录和未登录信息, 是否打卡等.

### 常见场景
1. 缓存
2. 数据库
3. 消息队列
4. 分布式锁
5. 点赞列表
6. 排行榜

### redis 过期key 的删除策略
1. 定时删除: 在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
   1. 对内存最友好：通过使用定时器，可以保证过期的键会尽可能快地被删除，释放所占内存
   2. 对cpu最不友好：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分cpu的时间，对服务器的响应时间和吞吐量造成影响
2. 惰性删除: 放任键的过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键.(使用的时候删除)
   1. 对cpu最友好：只有在取出键的时候才会对过期键进行检查，即不需要cpu定期扫描，也不需要创建大量的定时器。
   2. 对内存最不友好：如果一个键已经过期，但是后面不会被访问到的话，那么就一直保留在数据库中。如果这样的键过多，无疑会占用很大的内存。
3. 定期删除: 每隔一段时间，程序就对数据库进行一次检查，删除里面过期的键。至于要删除多少过期键，以及要检查多少个数据库，则有算法决定. (定期扫描删除)
   1. 定期删除每隔一段时间执行一次过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对cpu时间的影响； 
   2. 通过删除过期键，能有效的减少因为过期键而带来的内存浪
   3. 难以确定删除操作执行的时长和频率



#### redis过期策略需要注意的点
redis实际使用的过期键删除策略是定期删除策略和惰性删除策略：
redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会定时遍历这个字典来删除到期的 key。除了定时遍历之外，它还会使用惰性策略来删除过期的 key，所谓惰性策略就是在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除。定时删除是集中处理，惰性删除是零散处理。
通过配合使用这两种删除策略，服务器可以很好地合理使用cpu时间和避免浪费内存空间之间取得平衡。

1. 定期删除
Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略. 
   1. 从过期字典中随机 20 个 key；
   2. 删除这 20 个 key 中已经过期的 key；
   3. 如果过期的 key 比率超过 1/4，那就重复步骤 1；
   同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。

   如果某一时刻，有大量key同时过期，Redis 会持续扫描过期字典，造成客户端响应卡顿，因此设置过期时间时，就尽量避免这个问题，在设置过期时间时，可以给过期时间设置一个随机范围，避免同一时刻过期。

a. 如何配置定期删除执行时间间隔
    redis的定时任务默认是每秒执行10次，如果要修改这个值，可以在redis.conf中修改hz的值。
    redis.conf中，hz默认设为10，提高它的值将会占用更多的cpu，当然相应的redis将会更快的处理同时到期的许多key，以及更精确的去处理超时。 hz的取值范围是1~500，通常不建议超过100，只有在请求延时非常低的情况下可以将值提升到100。

b. 单线程的redis，如何知道要运行定时任务？
    redis是单线程的，线程不但要处理定时任务，还要处理客户端请求，线程不能阻塞在定时任务或处理客户端请求上，那么，redis是如何知道何时该运行定时任务的呢？
    Redis 的定时任务会记录在一个称为最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是接下来处理客户端请求的最大时长，若达到了该时长，则暂时不处理客户端请求而去运行定时任务。

2. 懒惰删除
    过期键的惰性删除删除策略由db.c/expireIfNeeded函数实现，所有读写数据库的Redis命令在执行之前都会调用expireIfNeed函数对输入键进行检查：
    如果键已经过期，那么expireIfNeeded函数将键删除
    如果键未过期，那么expireIfNeeded函数不做操作
    命令调用expireIfNeeded函数过程如下图



另外因为每个被访问的键都可能被删除，所以每个命令都必须能同时处理键存在以及不存在的情况。 下图表示get命令的执行过程



3. aof/rdb和复制功能对过期键的处理
   1. rdb:
   生成rdb文件：生成时，程序会对键进行检查，过期键不放入rdb文件。
   载入rdb文件：载入时，如果以主服务器模式运行，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会忽略；如果以从服务器模式运行，无论键过期与否，均会载入数据库中，过期键会通过与主服务器同步而删除。 
   2. aof:
   当服务器以aof持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被删除，那么aof文件不会因为这个过期键而产生任何影响；当过期键被删除后，程序会向aof文件追加一条del命令来显式记录该键已被删除。
   aof重写过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的aof文件中。
   复制

    当服务器运行在复制模式下时，从服务器的过期删除动作由主服务器控制：
    
    主服务器在删除一个过期键后，会显式地向所有从服务器发送一个del命令，告知从服务器删除这个过期键;
    从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键;
    从服务器只有在接到主服务器发来的del命令后，才会删除过期键。

### 缓存淘汰算法
1. LRU
2. LFU


### Redis的淘汰策略
1. noeviction(默认): 当内存使用超过配置的时候会返回错误, 不会驱逐任何建
2. allkey-lru: 加入键的时候,如果过限, 首先通过LRR算法驱逐最久没有使用的键
3. volatile-lru: 加入键的时候如果过限, 首先从设置了过期时间的键集合中驱逐最久没有使用的键



# 题目总结
1. redis 为什么快？
   1. 基于内存存储实现
   2. 高效的数据结构
      1. SDS简单动态字符串
         1. 字符串长度处理：redis 获取字符串长度，时间复杂度为O(1), 而C语言中需要重头开始遍历，复杂度O(n)
         2. 空间预分配： 字符串修改越频繁的话，内存分配越频繁，就会消耗性能，而SDS修改和空间扩容，会额外的分配空间减少性能损耗
         3. 惰性的空间释放： SDS缩短是， 不是回收多余的内存空间， 而是free记录下多余的空间后续有变化，直接使用free中记录的空间，减少分配
         4. 字典： redis  作为k-v型数据库，所有的键值就是用字典来存储的，字典就是哈希表，比如HashMap， 通过key 就可以直接获取到对应的value，而哈希表的特性， 在O(1)的时间复杂度就可以获取对应的值。
         5. 跳跃表： 跳表是redis特有的数据结构，就是在链表的基础上，增加多级索引提高查找效率； 跳跃表支持平均O(logN), 最坏O(N)的时间复杂度的节点查找，还可以通过顺序操作批量处理节点。
         6. 合理的数据编码 ： redis 支持多种数据类型，每种基本类型，可能对多种数据结构， 什么时候使用什么编码， 是redis设计这总结的结果
            1. String： 如果存储数字的话，是int类型的编码；如果是存储的是非数字，小于等于39子节的字符串， 是embstr； 大于39子节的字符串，则是raw编码。
            2. List：如果列表的元素不超过512个，列表每个元素的值都小于64，则使用ziplist编码，否则使用linkedlist编码
            3. Hash：哈希类型的元素个数小于512个，每个元素的值都小于64，则使用ziplist编码，否则使用hastable编码
            4. Set： 如果集合中的元素都是整数且元素个数小于512个，使用inset编码，否则使用hashtable
            5. Zset：当有序集合的元素个数小于128个，每个元素的值小于64子节时，使用ziplist编码，否则使用skiplist（跳跃表）编码
         7. 合理线程模型： IO多路复用模型
            1. IO多路复用模型技术可以让单个线程高效的处理多个连接请求，而redis使用epoll做为IO多路复用模型技术的实现，并且，redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为事件，不再网络IO上浪费过多的时间
2. redis 有几种数据结构？
                      操作实例：
      1. String ：     set key value, get key 
      2. Hash : hset key fied value, hget key field
      3. List : lpush key value [value ...], lrange key start end
      4. Set: sadd key element [element ...], smembers key 
      5. Zset: zadd key score member [score member...], zrank key memeber
      6. Geospatial: 地理位置定位，用于存储地理位置信息
      7. Hyperloglog： 用来做基数统计算法的数据结构，如统计网站的UV
      8. Bitmap： 用一个比特位来映射某个元素的状态， 在redis中， 它底层是基于字符串类型实现的， 可以以把bitmaps作为一个以比特位为单位的数组。
    
3. redis有几种持久化方式
   1. RDB
   2. AOF
4. 多线程情况下如何保证线程安全
   1. 加锁
5. 用过volatile吗？底层原理
   1. volatile关键字是java虚拟机提供的最轻量级的同步机制， 它作为一个修饰符， 用来修饰变量。 它可以保证变量对线程的可见性，禁止指令重排序，但不保证原子性
      ：java的内存模型（jmm）
      1. java虚拟机规范定义一种java内存模型，来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各个平台上都能达到一致的内存访问效果
      2. java内存模型规定所有的变量都是存在主内存当中的，每个线程都有自己的工作内存。这例的变量不包括局部变量，因为局部变量是线程私有的。
      3. 线程的工作内存保存例被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作中进行，而且不能直接操作主内存， 并且每个线程不能访问其他线程的工作内存
   2. volatile变量，保证例新值能立即同步回主内存，以及每次使用前立即从主内存刷新，所以我们说volatile关键字保证了多线程操作的可见性。
6. Mysql 索引结构，聚簇索引和非聚簇索引的区别
   1. 一个表中只能有一个聚簇索引, 而非聚簇索引可以有多个
   2. 索引是通过二叉树的数据结构来描述的，我们可以理解：索引的叶子节点就是数据节点 。 而非聚簇索引的叶子节点仍然是索引节点，只不过有一个指针指向对应的数据块。
   3.  聚簇索引：物理存储按照索引排序， 非聚簇索引： 物理存储不按照索引排序
7. Mysql 的高可以方案，自己用的哪一种
   1. 主从复制或主主复制
   2. 半同步复制优化
   3. 高可用架构优化
   4. 共享存储
   5. 分布式协议
8. 说说最有挑战的项目
9. 秒杀采用的是什么方案
10. 分库分表需要停服吗
11. redis 挂了怎么办
12. 优惠券如何防止重刷
13. 抖音评论系统如何设计
14. 如何设计一个短链地址
15. 有一个数组， 里面元素非重复， 先升序再降序， 找到里面的最大值