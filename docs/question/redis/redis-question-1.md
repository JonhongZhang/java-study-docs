### redis 的速度为什么快
    1. 基于内存: Redis是使用内存存储,没有磁盘IO上的开销, 数据在内存中,读写速度快
    2. 单线程实现: 在 Redis6.0 之前 -> Redis使用单个线程处理请求, 避免多个线程切换和锁资源竞争的开销.
    3. IO多路复用模型: Redis采用IO多路复用技术. Redis使用单线程来轮询描述付, 将数据库的操作都转换成事件,不在网络I/Os上浪费过多时间
    4. 高效的数据结构: Redis 每种数据结构底层都做了优化(for example), 目的就是为了最求更快的速度.

### Redis中单线程的优势
    1. 单线程实现可以避免过多的上下文切换开销,程序始终运行在进程中单个线程内, 没有多个线程切换的场景
    2. 避免同步机制的开销. 如果Redis选择多线程模型,需要考虑数据同步的问题, 则必然引入 各种同步机制, 会导致在操作数据的过程中带来更多开销, 用来保证数据同步,增加程序的复杂度,同时降低性能.
    3. 实现简单, 方便维护. 如果Redis使用多线程模式. 那么所有的底层数据结构的设计都必须考虑线程安全问题, 那么Redis的实现将会变得更加复杂.

### Redis的应用场景
    1. 缓存热点数据,降低数据库的压力
    2. 利用Redis的原子性的自增操作,可以实现计数器的功能,比如用户统计点赞数, 用户访问数等.
    3. 作为简单的消息队列,实现异步操作.
    4. 限速器, 可用于现在某个用户访问接口的频率.比如秒杀场景用于防止用户快速点击带来的不必要压力.
    5. 好友关系, 利用集合的一些命令,比如交集,并集,差集等,实现共同好友.共同爱好之类的功能.

### Redis怎么实现消息队列
    1. 使用列表, 让生产者将任务使用LPUSH命令放进列表,消费者不断用RPOP, 从列表中取数据
    2. 发布订阅模式. 类似于MQ的主题模式, 只能消息订阅之后发布的消息,一个消息可以被多个订阅者消费.
    3. 延时队列.使用sortedset, 拿时间戳作为score, 消息内容作为key,  调用zadd来生产消息, 消费者用 zrangebyscore 指令获取n秒之前的数据来进行处理 (什么事延迟队列) 

### Redis中从复制的原理
    REDIS 的复制功能是支持多个数据库之间的数据同步, 主数据库可以进行读写操作,当主数据库的数据发生变化自动将数据同步到从数据库;.从数据库一般是只读的, 它会接收主数据库同步过来的数据.
    1. 当启动一个节点是,它会发送一个 'PSYNC'命令给主节点;
    2. 如果是从节点初次链接到主节点, 那么会触发一次全量复制. 此时主节点会启动一个后台线程, 开始生成一个RDB的快照文件
    3. 同时还会将从客户端client 新收到的所有写命令缓存在内存中. RDBD文件生成完毕后,主节点会将RDB文件发送给从节点, 从节点会将RDB文件写入本地磁盘,然后再从本地磁盘加载到内存中;
    4. 接着主节点会将内存缓存的写命令发送到从节点, 从节点同步这些数据
    5. 如果从节点和主节点之间的网络出现故障. 链接断开了, 会自动重连, 链接之后主节点仅会将部分缺少的数据同步给从节点

### 过期删除策略 
    1. 别动删除, 在访问key时,检查key 是否过期,如果已经过期那么将key删除.
    2. 主动删除, 定时清理key, 每次清理会依次遍历所有DB, 从db随机取20个key, 如果过期就删除, 如果其中有5个key过期, 那么就继续对这个db进行清理, 否则开始清理下一个
    3. 内存不够时清理: Redis最大内存限制, 可以通过maxmemory参数可以设置最大内存,当使用的内存超过了设置的最大内存,就要进行内存释放, 在进行内存释放的时候, 会按照噢诶这的淘汰策略进行内存清理

