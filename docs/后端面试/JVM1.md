 1. 什么情况下会发生栈内存溢出？
    1. 栈是线程私有的 它的生命周期是与线程相同，每个方法在执行的时候，都会创建一个栈帧（Current Stack Frame），栈帧包含：局部变量表（Local  Variable Table ），操作栈(Operand Stack)，动态链接(Dynamic Linking)，返回地址(Return Address); 局部变量表： 基本数据类型，对象的引用；
        当线程请求栈深度，超过虚拟机允许的最大深度时，就会报栈溢出。如，当方法递归调用时，可以通过调整参数，调整JVM栈的大；

 2. JVM模型是怎样的？
    1. JVM将虚拟机分为 五大区域，包括，程序计数器，虚拟机栈，本地方法栈，java堆， 方法区；
                程序计数器： 线程私有，他是一个非常小的内存空间，可以作为当前线程一些行号的指示器，用来记录当前虚拟机正在执行的指令地址
                虚拟机栈：  线程私有，；
                本地方法栈： 线程私有，保存的是native 方法的相关信息，当jvm创建一个线程，调用native方法的时候，jvm是不会在虚拟机栈中为该线程创建栈帧的，而是简单的动态链接调用该方法。
                JAVA堆：  是所有线程共享的一块最大块的内存，几乎所有的对象的实例，数组都需要在堆上分配内存，因此该区域，会经常发生垃圾回收的操作。
                方法区： 已被加载的类信息，常量，静态变量，即使编译器编译后的常量数据，jdk1.8之中就不存在方法区，而是被原数据取代-原数据区，元方法区被分为两部分，一是加载到的类信息（元数据区中），二运行时的常量池（堆中）；

 3. JVM模型中一次完整的GC是怎样的？ 对象如何晋升到老年代？
    java堆是，分为新生代，和老年代；                    每次minor GC 都会使存活的对象年龄加一，比如阀值为15时，即可晋升到老年代，大对象除外；
            -XX:+MaxTennuringThreshold 可配置对象的年龄的阀值，最大为15；
    当老年代满时，触发FUll GC;
    伴随着Minor GC，Major GC是用来处理清理老年代；
        四种算法，特点：
            1. 标记清楚法      - 可达性分析，2次便利完成，
            2. 标记整理法      - 可达性分析 -》 对象整理 -》清楚  （适合存活对象多，垃圾少，需要整理的情况）
            3. 复制算法        - 将内存中，按照容量大小相等的两个大小；（不会产生碎片，浪费一片空间）
            4. 分代收集        - 分代收集算法，将对象的存活周期不同， 把内存划分为几块，如虚拟机分为，新生代，老年代；新声代，以其特性使用复制算法；老年代，标记清理，标记整理；
        算法在那里使用喃？
            CMS -- 标记清除； G1 --- 标记整理/复制； parNew是启动CMS搜集器，时，新生代的默认收集器，并行收集；
    
    如何判断对象是否存活：？
        1. 引用计数法，当引用计数器为0时，则可回收； 存在循环引用的问题；
        2. 可达性分析法， 从一个GC ROOT集合中，如果对象到GC root没有引用的，（虚拟机栈中引用的对象，方法区中的静态变量，方法区中常量池引用的对象，本地方法栈CMI 引用的对象；）在进行两次标记，、第一次： 判断对象是否存在finallaze 方法，并且该方法没有被执行过， 如果不存在则标记为垃圾对象，等待回收，如果有则进行第二次标记，当前对象放入一个Q队列里面，并生成一个finallaze线程进行执行finallaze方法, 虚拟机不保证执行该方法（因为该线程如果加锁，可能会导致死锁，从而进一步导致回收系统奔溃），如果执行该方法final，依然没有与GC ROOT 存在直接或者间接的关系，那么对象就可以被回收了；标记清除，标记可达性对象，清除不可达对象。
    
    有几种垃圾回收器，有哪些优缺点，CMS与G1的区别？
        年轻代： Serial， PerNew, Parallel Scavenge,  G1
        老年代： CMS , Serial Old  , Parallel old , G1

        Serial: 复制算法；单线程，在进行时回收时，所有的线程将暂停；高效简单，客户端模式下，可用；在互联网高并发下，作用不大；
        PerNew: 相当于 Serial的多线程版本，多条线程并行进行垃圾回收清理，但在进行回收时依然需要暂停所有用户线程, 时停较短;
        Parallel Scavenge: 这是一个多线程的垃圾收集器，该收集器 追求的是CPU高吞吐量的垃圾收集器,它能够在较短的时间内完成，垃圾收集；适合在没有用户交互的后台，进行计算 ；
        Serial Old: 标记整理，其他同Serial
        Parallel old: 同Parallel Scavenge
        CMS: 获取最短的GC停顿时间；stw--为了保证程序不会乱套；标记清除算法
        G1: 是java 7 第4个更新版本后，出现的垃圾处理器
                G1 回收的地址是连续的， 避免了CMS垃圾回收时地址空间不连续，所造成的问题（Full GC）；
                G1 将内存划分为一个一个的区域，内存回收以一个一个区域回收；
                G1 存在软实时特性，指定垃圾回收的限时，G1 不保证在时限内完成，但是以设置合理目标，让90%垃圾回收，在这个时间内回收；

 4. java垃圾回收知道吗？ 双亲委派模型是怎么回事？
        CMS 垃圾回收机制：以获取最小停顿时间为要求；用户响应速度快，并发高；
         1. 初始标记(STW)； 2. 并发标记； 3. 并发预清理；4. 重标记（STW）；5. 并发清理； 6.重置 ；（除开STW，其他与用户线程并行）
        
        初始标记： 1. 标记GC ROOT能直接管理到的对象； 2. 标记年轻代中，存活到老年代的对象；（所以他会扫描年轻代）
        并发标记： 与用户线程并发，通过GC root，从第一阶段标记的对象出发，标记所有的可达对象； （此时并发产生的新对象，无法标记）
        并发预清理；为了减少并发清理时的STW，所以进行并发预清理；这个阶段会对新从新生代，晋升到老年代的对象进行标记；新分配到老年代的对象进行标记； 以及在并发阶段修改了的对象；该阶段如果对象在并发标记阶段（将内存分区域块，如果并发阶段当前块中的对象发生变化，着标记这个区域块（章页）发生改变，被标记变化，则进行标记，会将（用户线程并行）
        重标记（STW）: 多线程进行重新标记；
        并发清理；清楚为被标记的对象；
        重置；
        默认CMS回收线程数： (CPU个数 + 3)/4 ; 当CPU超过4个，则占用1/4
        并发清理阶段，新产生的垃圾只能在下一次处理；新产生的垃圾（浮动垃圾）---- 所以规定，预留空间给用户线程，不能像其他回收器，等老年代满，在回收；
                CMSInitiatingOccupancyFraction 来设置老年代空间使用百分比， 默认92%；需要看具体情况， 太小产生大量停顿；太大，导致用户线程需要使用的空间大于，剩余空间时，将会导致Concurrent Mode Failure 错误；（并发模式失败）；CMS失败后，将会使用Serial old 收集器重新进行老年代回收；
        使用参数： UseCMSInitiatingOccupancyOnly 关闭CMS自动预测垃圾回收；
        CMS 产生大量碎片，可能会导致没有足够大的连续空间； 可以通过UseCMSCompactAtFullCollection参数，默认开启；意义为在内存空间不足，要进行FUllGC 时，开启内存碎片整理，该过程需要STW；停顿时间变成；
        参数CMSFullCsBeforeCompaction 默认为0； 该参数是，在进行了多少次FullGC后，进行一次代压缩的FullGC;
    本质是以空间换时间；

    G1 理解吗，说说对G1的理解；
        G1 设置最大的GC停顿实际：- XX:MaxGCPauseMillis=n (默认200ms-- 软性指标)
        G1 Region大小通过参数 -XX:G1HeadRegionSize设定，取值范围从1M到32M，且只是2的指数。
        G1在1.9后，作为默认的垃圾回收器；
        保持高回收的情况下，减少停顿时间；

        G1 的垃圾回收分为两部分： 1.年轻代 YGC ; 2.老年代 MIXGC;

        存在一个问题： 在进行YGC的时候，老年代的对象是不进行回收的，但是当我年轻代中，某个对象引用了老年代的对象，这种情况下，需要扫描老年代的对象；
        CMS中是通过 卡表 的的方式，记录老年代对象到新生代对象的引用；卡表是以连续的数组形式；G1也有此种方式，以避免扫描老年代
        --- G1 是以一种新的数据结构：Rset， 记录了，其他Region中的对象，引用自己Region中对象的  关系，谁引用了我的对象，CMS是-我引用了谁的对象。
        在G1的Rset中每一个Region，他会记录下别的Region指向自己的指针，并且标记这些指针在哪些卡表范围内，相当于HashTable,每一个Region都有一个Rset

        YGC通过Rset查找到old区引用young区的对象，避免扫描整个old区；
        
        老年代中的MIXGC: G1的MIXGC需要依赖 全局并发标记 来回收垃圾
        当堆内存使用达到了45%则进行并发标记阶段；
        比例可调： -XX:InitiatingHeadOccpuancyPercent 进行配置；
        1） 初始标记（initial mark） 「存在STW」
        2） Root 区扫描（Root Region Scan）
        3)  并发标记 （Concurrent Mark）
        4)  重新标记 （Remarking）「存在STW」
        5)  清理阶段 （Cleanup） 如果不全是则不会立刻处理，会等执行完后，等MixGC进行收集
        当五个阶段，获得垃圾占比，当占比达到某个阀值，这进行MixGC 
        阀值配置： -XX:G1HeapWastePercent参数配置（默认是堆大小的5%）

 5. 说说你项目中是如何优化JVM的？
    1. 系统秒杀时，CPU爆增；
        jstat -gc pid;
        查看堆是否有线程阻塞与死锁；
        redis链接池不够，数据库链接不够，大对象无法释放，应用负载高，导致多次FUll GC 

        

 6. 什么是类加载？ 类加载的过程？

    虚拟机把类信息加载到内存中，存在内存方法区中，并对数据进行校验，解析，初始化--最终变成虚拟机可使用的Class对象。

    加载：1. 通过类的全限定类名（类全名称代包名）， 如： java.lang.String ,获取二进制流  读进来
         2. 将该二进制流的静态的数据结构（类的静态存储结构就是 class 文件），转换为方法区里面运行时的数据结构；
         3. 在堆中为该类生产一个class对象。
    
    验证： 验证class文件中的字节流信息是否符合JVM的要求，是否会威胁到JVM的安全；

    准备： 验证完成后，为class的静态变量分配内存，初始化，初始化一些初始值；

    解析： 则阶段主要是将符号引用转换为直接引用； （类A引用类B， 在编译时A无法获取到B的内存地址，因此用B类名符合来代替，解析时把B类符合替换为B类的内存地址）

    初始化： 才开始执行内中定义的一些java的代码，如调用类的构造器。

7. 什么是类加载器，常见的类加载器有哪些？
    类加载器是：一个类获取该类的二进制字节流，读取二进制字节流的过程
    类加载器有：4种： 启动类加载器；扩展类加载器；系统类加载器；自定义类加载器

8. 什么是双亲委派模型？
    当一个类收到类加载请求时，首先不会自己加载，交由父类加载器，先从父类的类加载申请，如果不能则由子类加载；
9. 为什么需要双亲委派模型？
    在java中为了防止出现相同的字节码，避免产生多个String类，保证唯一性；
10. 怎么打破双亲委派模型？有何意义？
    继承自定类加载器， 重写loaderClass, 与findClass方法；
    意义-为什么？
    因为在某些情况下父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器无法加载到需要的文件，以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。
11. spi 机制，spi 机制本质是通过反射完成。

    缺点：遍历加载所有的实现类，这样效率还是相对较低的；当多个 ServiceLoader 同时 load 时，会有并发问题。

12. SpringBoot的SPI机制与自动装配
https://baijiahao.baidu.com/s?id=1724634306266520505&wfr=spider&for=pc