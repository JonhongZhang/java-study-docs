1. 做的项目，熟悉的业务，熟悉的技术栈
    做过的项目：电商项目，电商平台初期项目，商品租借推广项目，保险项目。
    熟悉电商、保险类业务，对金融行业有很大的兴趣。
    熟悉的技术栈，spring cloud: gateWay, oath2.0, spring springMVC , redis, mysql , Oracla jpa, mybatis, openfeign, nginx, Dubbo，WebService， nacos, zookeeper.
     

2. 项目中使用过哪些技术栈， 哪些技术是可以优化的，项目中权限管理是如何设计的（可以说说特色）；
    实际生产中，使用过 spring springMVC  Habinate, JPA, mybatis, OpenFegin, maven, springboot, zookeeper, Dubbo, WebService, nginx, gateway.
    存在可以优化的技术： Dubbo, nginx, gateway, zookeeper, OpenFegin
3. 项目中用到网关吗，谈谈你对网关的理解？
    理解：网关，可以说是一个其他部分的入口，一个大大的过滤处理器；
        在微服务中，网关可以说是一个统一的API服务器，是系统的唯一入口，为每个客户端，提供定制的restful API  同时他还有可以进行，鉴权，跨域，静态响应，负载均衡，黑名单，缓存，限流。

4. 在网关中如何设置限流
      Spring Cloud Gateway是Spring 官方基于Spring 5.0，Spring Boot 2.0和Project Reactor 等技术开发的网关，旨在为微服务架构提供一种简单而有效的统一的API路由管理方式，统一访问接口。Spring Cloud Gateway作为Spring Cloud 生态系中的网关，目标是替代Netflix ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。它是基于Nttey的响应式开发模式。


        2.1 核心概念：
        路由（route）：路由是网关最基础的部分，路由信息由一个ID，一个目的URL，一组断言工厂和一组Filter组成。

        断言（predicates）：java8中的断言函数，Spring Cloud Gateway中的断言函数允许开发者去定义匹配来自Http Request中的任何信息。当断言为真时，则匹配路由。

        过滤器（filter）：对请求和响应进行过滤

        在实际环境中会遇到这样的问题，同一时间会有许多请求去调用微服务，大量请求的进入很有可能导致微服务被破环，因此限流就变得很重要。

        3.1 常见的一些限流算法：

        计数器算法：设定一个单位时间内的计数值，如果单位时间内访问的请求大于这个设定的值，则之后的请求都拒绝。直到单位时间内的值低于这个值才继续接收。

        漏桶算法：我们可以把漏桶算法想象成一个漏斗。请求进来时先到漏斗中，然后按设定好的输出速率分配到微服务上。当一下子有很多请求进来时，只能在漏斗上等着。为了控制流量，需要设置两个变量：一个是桶的大小，另一个是漏斗流出的速率。 

        令牌桶算法：令牌桶算法是对漏桶算法的一种改进，相比于漏桶算法，令牌桶算法能允许一定程度的突发调用。令牌桶算法的原理：在令牌桶算法中，存在一个桶，用来存放固定数量的令牌，令牌会以一定速率放到桶中，桶中的令牌满了之后就不会再放令牌。当一个请求来临时，要先在令牌桶中拿到一个令牌，才能去调用微服务，当令牌桶中没有令牌的时候，后来到的请求就需要等待。令牌桶算法除了可以限流，还允许一定程度的突发调用：比如一个令牌桶的容量是100，在没有请求的时候，令牌桶中的令牌数量是满的。此时如果突然来了100个请求，那么这100个请求都能被立刻执行。


        3.2 基于Filter的限流实践

        SpringCloudGateway官方就提供了基于令牌桶的限流支持，基于其内置的过滤器工厂

        RequestRateLimiterGatewayFilterFactory 实现。在过滤器工厂中是通过Redis和lua脚本结合的方

        式进行流量控制。所以我们可以通过配置redis，在redis中看到运行的情况。

5. 网关中有没有出现过过载的情况？如果出现过载，会出现什么样的情况，一般是如何进行处理的？（https://zhuanlan.zhihu.com/p/374425419）
     过载保护
        系统在设计之初就会有一个预估容量，超过系统所能承受的容量阈值称为过载。长时间超过系统能承受的容量阈值，系统可能会被压垮，最终导致整个服务不可用。

        为了避免这类情况的发生，需要对系统进行过载保护。一般方式有：流量控制、熔断和服务升降级。
    流量控制： 
        流量控制的目的是通过对「并发访问请求数量进行控制」或者「一个时间窗口内的的请求数量进行控制」来保护系统，一旦达到控制速率则可以拒绝服务、排队或等待。

        流量控制可以针对整个系统，也可以针对单个接口来进行控制。

        网关需要控制单位时间内接口允许被调用次数，以保护后端服务，实现用户分级。 可以根据接口的重要程度来配置不同流控，从而保障重要业务的稳定运行；支持用户、应用和例外流控，可以根据用户的重要性来配置不同流控，从而可以保证大用户的权益； 流控粒度：分钟、小时、天。
    熔断
        当一个服务对外无响应或者响应时间很长时，此种情况下可能会导致请求的大量积压，继而影响整个系统对外提供服务。熔断可以避免此类问题的发生。

        当一个服务对外无响应或者响应时间过长时，对该服务进行熔断操作。即对该服务的请求立即返回特定的结果，避免请求积压。等一段时间后，恢复服务对外提供服务。如果服务还是无法对外服务，则再次触发熔断。
    服务升降级
        上面的流量控制和熔断都是相对比较「公平」的方法，主要是为了保证系统的可用性。在系统过载的情况下，无差别的对待所有的服务/接口。

        不过对于一个系统来说，有些服务是核心服务而有些服务是非核心服务，对于核心服务来说，即使在系统过载的情况下也不能拒绝对外服务，否则这个系统实际就失去了它原有的价值。这个时候就需要非核心业务为核心业务让路，即在系统过载的时候，非核心服务让出系统资源，即服务降级，保障核心服务能稳定的对外提供服务。待系统负载正常后，再恢复非核心服务。
    缓存
        对于经常调用的接口，且结果基本不会出现变化的接口，可以对这些接口进行缓存。缓存后的接口，由于请求不会到达目标服务端，可以给系统带来如下好处：

        减少了请求链路
        降低了系统的响应时间
        降低了微服务的负载
        同时也带来了如下劣势：

        需要同步缓存与接口结果，增加了开发难度
        需要管理缓存，增加运维成本
        在后端并发和处理能力不够的情况下，将缓存前置来提供更好的服务，而且是从网关层统一处理，可简化后端服务处理的复杂度。
6. 使用redis是否存在key存不下的情况？
    redis 中key 最大为512M, 基本大多数情况下的key都可以存下，只是存在key过大，以及value 过大导致的大key问题，处理这类问题主要是通过对key进行优化，对value进行拆分，并且在对大key进行删除需进行特殊删除，注意scan命令的使用。
7. 项目中定时任务是通过什么技术实现的，定时任务 spring task与 quartz 有着怎样的区别？他们的底层使用的是什么技术，java原生的timer task实现定时任务，可能会出现哪些问题？
    spring task实际上是一种轻量级的quartz，实现的方式比quartz简单很多；quartz使用起来灵活，而spring task使用起来简单；
    corn 从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份
                    spring task 中的cron只有6个：        {秒} {分} {时} {日期（具体哪天）} {月} {星期}
    quartz:  特性-（1）强大的调度功能，例如支持丰富多样的调度方法，可以满足各种常规及特殊需求；
                 （2）灵活的应用方式，例如支持任务和调度的多种组合方式，支持调度数据的多种存储方式；
                 （3）分布式和集群能力，Terracotta收购后在原来功能基础上作了进一步提升。
    
8. mybatis中的分页插件是如何实现的？如何防止sql注入？ Executer执行器分别有哪些区别？
        1. 利用mybatis扩展插件机制，以支持外部进行任意扩展，在启动时将interceptor, 添加的mybatis的上下文中。在查询是触发实例化动作；
                1. 先解析各位置参数;2. 初始化 pageHelper 实例, 即 dialect;3. 调用方法判断是否需要进行分页，如果不需要，直接返回结果;4. 判断是否要进行count, 如果需要则实现一次count, ;5. 查询分页结果;6. 封装带分页的结果返回;

        2. 如何防止sql注入： 1-. 代码层防止sql注入攻击的最佳方案就是sql预编译; 2-. 确认每种数据的类型，比如是数字，数据库则必须使用int类型来存储;
                            3-. 规定数据长度，能在一定程度上防止sql注入; 4-. 严格限制数据库权限，能最大程度减少sql注入的危害; 5-. 避免直接响应一些sql异常信息，sql发生异常后，自定义异常进行响应; 6-. 过滤参数中含有的一些数据库关键词.
        3. Executer执行器分别有哪些区别？
                mybatis有三种executor执行器，分别为simpleexecutor、reuseexecutor、batchexecutor。
                simpleexecutor执行器：在每执行一次update或select，就开启一个statement对象，用完后就关闭。
                reuseexecutor执行器：在执行update或select时以sql作为key去查找statement，有就直接使用，没有就创建，使用完毕后不关闭，放入Map<String,Statement>中，供下次使用。重复使用statement。
                batchexecutor执行器：执行update（jdbc批处理不支持select），会把所有sql添加到批处理中addbatch（）；等待统一批处理executorbatch（）；它缓存了·多个statement，每一个statement都是addbatch（），后等待进行executorbatch（）批处理。
                作用范围：统一限制在sqlsession生命周期范围内。
            
9. 对于ORM框架的理解？
        对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。ORM框架是连接数据库的桥梁，只要提供了持久化类与表的映射关系，ORM框架在运行时就能参照映射文件的信息，把对象持久化到数据库中。

        ORM框架：为了解决面型对象与关系数据库存在的互不匹配的现象的框架。

        当前ORM框架主要有五种：
        （1）Hibernate 全自动 需要写hql语句
        （2）iBATIS 半自动 自己写sql语句,可操作性强,小巧
        （3）mybatis
        （4）eclipseLink
        （5）JFinal

        当我们实现一个应用程序时（不使用O/R Mapping），我们可能会写特别多数据访问层的代码，从数据库保存、删除、读取对象信息，而这些代码都是重复的。而使用ORM则会大大减少重复性代码。对象关系映射（Object Relational Mapping，简称ORM），主要实现程序对象到关系数据库数据的映射。
       
        优点：
        1）提高开发效率，降低开发成本
        2）使开发更加对象化
        3）可移植
        4）可以很方便地引入数据缓存之类的附加功能
        缺点：
        1）自动化进行关系数据库的映射需要消耗系统性能。其实这里的性能消耗还好啦，一般来说都可以忽略之。
        2）在处理多表联查、where条件复杂之类的查询时，ORM的语法会变得复杂。

10. 使用过哪些ORM框架，分别适用哪些场景？
        Hibernate配置要比mybatis复杂的多，学习成本也比MyBatis高。MyBatis，简单、高效、灵活，但是需要自己维护SQL；
        Hibernate功能强大、全自动、适配不同数据库，但是非常复杂，灵活性稍差。

11. 谈谈数据库的水平拆分，垂直拆分，如何选择； 如何选择技术方案实现数据的一致性，如何兼顾数据一致性与效率的平衡，如果存在两个系统之间的数据交互，如何保证数据的一致性，如何保证数据传输过程中不会被篡改
        数据拆分前其实是要首先做准备工作的，然后才是开始数据拆分:
            第一步：采用分布式缓存redis、memcached等降低对数据库的读操作。
            第二步：如果缓存使用过后，数据库访问量还是非常大，可以考虑数据库读、写分离原则。
            第三步：当我们使用读写分离、缓存后，数据库的压力还是很大的时候，这就需要使用到数据库拆分了。
        数据库拆分原则：就是指通过某种特定的条件，按照某个维度，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面以达到分散单库（主机）负载的效果。

        第一步，首选垂直拆分
            一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面 。

            比如淘宝中期开始的数据库端按照业务垂直拆分：按照业务交易数据库、用户数据库、商品数据库、店铺数据库等进行拆分。

            采用垂直拆分优点：

            拆分后业务清晰，拆分规则明确。
            系统之间整合或扩展容易。
            数据维护简单。
            缺点：

            部分业务表无法join，只能通过接口方式解决，提高了系统复杂度。
            受每种业务不同的限制存在单库性能瓶颈，不易数据扩展跟性能提高。
            事务处理复杂。
        第二步：其次才是水平拆分
            水平拆分的典型场景就是大家熟知的分库分表。
            垂直拆分后遇到单机瓶颈，可以使用水平拆分。
            相对于垂直拆分的区别是：
                垂直拆分是把不同的表拆到不同的数据库中，而水平拆分是把同一个表拆到不同的数据库中。
            相对于垂直拆分，水平拆分不是将表的数据做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中的某些行切分到一个数据库，而另外的某些行又切分到其他的数据库中。
        
        1.优先考虑缓存降低对数据库的读操作。

        2.再考虑读写分离，降低数据库写操作。

        3.最后开始数据拆分,切分模式： 首先垂直（纵向）拆分、再次水平拆分。

        4.首先考虑按照业务垂直拆分。

        5.再考虑水平拆分：先分库(设置数据路由规则，把数据分配到不同的库中)

        6.最后再考虑分表，单表拆分到数据1000万以内。

12. 常用的加密方式有哪些？优缺点？ 算法原理？
        而常见的密钥加密算法类型大体可以分为三类：对称加密、非对称加密、单向加密
        对称加密：在加密传输中最初是采用对称密钥方式，也就是加密和解密都用相同的密钥。
                过程：1.对称加密算法采用单密钥加密，在通信过程中，数据发送方将原始数据分割成固定大小的块，经过密钥和加密算法逐个加密后，发送给接收方
                     2.接收方收到加密后的报文后，结合解密算法使用相同密钥解密组合后得出原始数据。
                优点： 是效率高，算法简单，系统开销小，适合加密大量数据。
                缺点：   安全性差
                        加解密算法是公开的，因此在这过程中，密钥的安全传递就成为了至关重要的事了。而密钥通常来说是通过双方协商，以物理的方式传递给对方，或者利用第三方平台传递给对方，一旦这过程出现了密钥泄露，不怀好意的人就能结合相应的算法拦截解密出其加密传输的内容。
                        扩展性差
                        每对通信用户之间都需要协商密钥，n个用户的团体就需要协商n*(n-1)/2个不同的密钥，不便于管理；而如果都使用相同密钥的话，密钥被泄漏的机率大大增加，加密也就失去了意义
                常见的对称加密算法
                    DES：分组式加密算法，以64位为分组对数据加密，加解密使用同一个算法。
                    3DES：三重数据加密算法，对每个数据块应用三次DES加密算法。
                    AES：高级加密标准算法，是美国联邦政府采用的一种区块加密标准，用于替代原先的DES，目前已被广泛应用。
                    Blowfish：Blowfish算法是一个64位分组及可变密钥长度的对称密钥分组密码算法，可用来加密64比特长度的字符串。

        非对称加密：非对称加密算法采用公钥和私钥两种不同的密码来进行加解密。公钥和私钥是成对存在，公钥是从私钥中提取产生公开给所有人的，如果使用公钥对数据进行加密，那么只有对应的私钥（不能公开）才能解密，反之亦然。N 个用户通信，需要2N个密钥。非对称密钥加密适合对密钥或身份信息等敏感信息加密，从而在安全性上满足用户的需求。
            过程： 1.甲使用乙的公钥并结合相应的非对称算法将明文加密后发送给乙，并将密文发送给乙。
                  2.乙收到密文后，结合自己的私钥和非对称算法解密得到明文，得到最初的明文。    
                优点： 具有比对称密钥加/解密方式更高的安全性，因为加密和解密用的是不同密钥，而且无法从一个密钥推导出另一个密钥，且公钥加密的信息只能用同一方的私钥进行解密。
                缺点： 1.非对称密钥加密的缺点是算法非常复杂，导致加密大量数据所用的时间较长，只适合对少量数据进行加密。而且由于在加密过程中会添加较多附加信息，使得加密后的报文比较长，容易造成数据分片，不利于网络传输。
                      2.无法确认公钥的来源合法性以及数据的完整性。如何确认我们接下来会说
                常见非对称加密算法
                RSA：RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，可用于加密，也能用于签名。
                DSA：数字签名算法，仅能用于签名，不能用于加解密。
                DSS：数字签名标准，技能用于签名，也可以用于加解密。
                ELGamal：利用离散对数的原理对数据进行加解密或数据签名，其速度是最慢的。

13. 谈一谈JVM内存结构？每个区都有什么作用？
        首先关于jvm内存结构，会有6个部分，这6部分根据这3点加以区分：必须实现还是选择实现；每个线程私有还是所有线程共享；出现异常StackOverflowError可能发生部分，异常OutOfMemoryError可能发生的部分。 

        JVM 内存结构：
                根据规定虚拟机结构并不是虚拟机规范严格所限制的，实现基本读取class文件和一些操作外，不同执行引擎会不同，例如运行时数据区在内存的布局，垃圾回收器算法的使用，或者优化如何翻译成机器码。
            对于运行时数据区域，也就是jvm内存，有6个结构，他们有的是在jvm生命周期而初始化或者销毁的，有的则是跟随线程的生命周期初始化或销毁。
            1.程序计数寄存器（ program counter Register），虚拟机是多线程的，每个线程都有自己的计数寄存器，线程的当前方法如果是不是本地（native）方法，计数寄存器记录的是jvm正在执行指令的地址；如果是本地方法，计数寄存器的值是未定义（undefined）

            2.虚拟机栈（Java Virtual Machine Stacks），每个线程都有一个jvm栈（这是栈一段内存空间，不是数据结构的栈，和数据结构栈类似，fifo），保存在桢（frames）里；jvm栈在方法调用时创建，并保存了当前线程的本地变量和局部变量，保存jvm栈的桢可能是在堆（heap）上分配的，而且内存结构上不要去jvm栈是连续的。
            jvm栈创建时可以是每个单独设置固定大小或者统一动态伸缩的方式，动态伸缩是通过初始化参数的最大值和最小值（maximun and minimum size）控制的。
            有两个著名的错误就和jvm栈有关：StackOverflowError，由于线程需要的jvm栈大于能够提供的大小；OutOfMemoryError ，由于jvm栈尝试动态扩张的时候没有足够的内存空间，或者新线程要创建jvm栈但是内存空间不足；

            3.堆（Heap），堆是被所有线程所共享的，它是jvm启动时候就初始化的运行时数据区域，所有类的实例和数组都是从这里分配的内存。堆存储的对象不会明确的释放，但是会被自动存储管理系统（垃圾回收gc）进行回收的，jvm规范没有要求gc清除特定的类型，具体选择由实现者去决定；堆可能也是固定大小或者动态扩缩容量的，动态伸缩控制也是参数堆最大最小值，内存结构上也是不要求连续性。
            同样当计算需要堆的大小超过gc能提供的大小同样出现OutOfMemoryError

            4.方法区（Method Area），方法区也是被所有线程所共享的，它是jvm启动时就初始化，用来保存了每个类的结构，例如运行时常量池，属性和方法的数据，特殊方法和构造器的代码。尽管方法区逻辑上是堆的一部分，但是jvm规范并没有要求有方法区，或者方法区如何管理编译的代码，所以实现方式中可能是被gc回收或压缩，也是同堆一样内存不要求连续，可通过参数调整，也会出现OutOfMemoryError

            5.运行时常量池（Run-Time Constant Pool），运行时常量池保存了在class文件里属于常量池表（constant_pool table）的内容（常量池表，是为了方便jvm指令引用，包含17种常量，https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html#jvms-4.4），运行时常量池提供的功能类似一般编程语言的符号表，但是它包含内容远多于符号表，既能存放编译时确定的数字字面值，也能保存运行时才确定的方法或者属性的引用对象。运行时常量池分配在方法区内，会在jvm加载类或者接口时候就被构造好。
            当创建类或者接口时如果构造需要的空间不能被方法区满足也会出现OutOfMemoryError

            6.本地方法栈（Native Method Stacks），jvm可能用到传统的栈，用来配合本地方法（不实用java写的方法），本地方法也可能会用到jvm的指令集。jvm的实现如果不要本地方法或者本地方法用的传统栈，那么本地方法栈就可以不用提供，但是要用的话就得在每个用到本地方法的线程分别分配本地方法栈。本地方法栈可以时固定或者动态伸缩的，如果是固定大小，每个本地方法栈就要单独分配大小。本地方法栈类似jvm栈，所以当计算中需要的本地方法栈大于可以提供的大小，出现StackOverflowError；本地方法栈扩张时候没有足够空间，或者新线程创建本地方法栈没有足够空间，出现OutOfMemoryError。



14. 当一个类加载的时候，他的方法变量分别进入什么区？
    
15. 判断一个对象能被垃圾回收，都有那几种算法？
    引用计数法，可达性法
16. 什么是java类的加载机制，java中的堆栈都有什么样的区别
        Java中的堆和栈以及堆栈的区别：
            1.栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 

            2. 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共 享，详见第3点。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要 在运行时动态分配内存，存取速度较慢。 

            3. Java中的数据类型有两种。 
                        一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出 后，字段值就消失了)，出于追求速度的原因，就存在于栈中

                        另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义： 
                                编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处 理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。 

                        　　特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另 一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完 a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地 址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。 

                        　　另一种是包装类数据，如Integer, String, Double 等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创 建，因此比较灵活，但缺点是要占用更多的时间。

            4. String是一个特殊的包装类数据。即可以用String str = new String("abc");的形式来创建，也可以用String str = "abc"；的形式来创建(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java 中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单 例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String str = "abc"；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。

            5. 关于String str = "abc"的内部工作。Java内部将此语句转化为以下几个步骤： 
                        (1)先定义一个名为str的对String类的对象引用变量：String str； 

                    　　(2)在栈中查找有没有存放值为"abc"的地址，如果没有，则开辟一个存放字面值为"abc"的地址，接着创建一个新的String类的对象o，并 将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为"abc"的地址，则查找对象o，并返回o的地址。 

                    　　(3)将str指向对象o的地址。 

                        值得注意的是，一般String类中字符串值都是直接存值的。但像String str = "abc"；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！

                        以上两段代码说明，只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。 
            
            6. 数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的数据类型包装类都不能更改其内部的值。 

            7. 结论与建议： 
                    (1)我们在使用诸如String str = "abc"；的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向 String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因 此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为"abc"的String类。清醒地认 识到这一点对排除程序中难以发现的bug是很有帮助的。 

                　　(2)使用String str = "abc"；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String("abc")；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是 享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。 

                　　(3)当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。 

                　　(4)由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。 
            「https://www.cnblogs.com/sxyBlog/p/9989288.html」
            
17. 常用的垃圾回收算法都有哪几种?
    标记清楚算法、标记整理算法、复制算法、分带搜集；

18. G1垃圾回收器都用了哪些算法？

19. jps和jstat两个调优命令分别有什么做用？

20. 什么是内存溢出，请用代码实现？

21. 什么是内存泄漏，请用代码实现？

22. 内存泄漏和内存溢出有什么样的区别？

23. 什么是乐观锁，什么是悲观锁？

24. synchronized 是乐观锁还是悲观锁？

25.  synchronized修饰类，变量，方法有什么区别？

26. 什么叫做线程的死锁？实现死锁？

27. 如何排查死锁？

28. 如何在多线程中共享一个变量? 有哪些方法？

29. 为什么要慎用threadloacl, 使用时应该注意什么？

30. 创建线程次的方式有哪些？优缺点？

31. 一个生产上的项目，过一段时间就down掉了，如何排查原因？

32. 空余时间如何提升自己？

33. 职业规划？走技术管理，还是纯技术路线？

34. 
